La forma más óptima de abordar la seguridad del acceso de usuarios en tu aplicación web **Laravel** (usando **POO** y **MySQL**) implica una combinación de las características de seguridad nativas de **Laravel** con lógica personalizada para cumplir con las políticas específicas de la empresa.

Aquí está la estrategia detallada para implementar las cuatro políticas solicitadas:

## 1\. Encriptación del NIP (Contraseña)

**Laravel** maneja esto de forma nativa y segura.

  * **Problema Actual:** El NIP está almacenado como texto plano, lo que es una vulnerabilidad grave.
  * **Solución Óptima:**
      * Utilizar la función `bcrypt()` de **Laravel** o el *Facade* `Hash` para hashear el NIP antes de guardarlo en la base de datos. **NO** es una encriptación reversible, sino un *hashing* seguro.
      * **En el modelo:** Asegúrate de que tu modelo **`User`** (o equivalente de la tabla `USUARIOS`) use el *trait* `Illuminate\Auth\Authenticatable` (por defecto en el modelo `User` de Laravel) y que el campo del NIP esté configurado correctamente.
      * **En el *Seeder* o *Registro*:** Al crear un nuevo usuario o cambiar el NIP, usa:
        ```php
        $user->nip = Hash::make($nip_plano);
        $user->save();
        // O más conciso:
        // 'nip' => bcrypt($nip_plano), // Al crear el usuario
        ```
      * **En la Autenticación:** El *scaffold* de autenticación de **Laravel** (usando el *Auth facade* o *middleware*) automáticamente compara el NIP ingresado con el *hash* almacenado utilizando la función `Hash::check()`, lo que garantiza que nunca se trabaje con el texto plano.

## 2\. Validación de Patrón para Correo y NIP

Se implementará a nivel de **Validación de Solicitudes (Request Validation)** en **Laravel**.

  * **Solución Óptima:**
      * Crea una **`LoginRequest`** o utiliza la validación dentro del controlador de *Login*.
      * Utiliza **Expresiones Regulares** (`regex`) en las reglas de validación para asegurar el patrón requerido.
      * **Ejemplo (asumiendo reglas comunes):**
        ```php
        // En el método rules() de un Form Request
        public function rules()
        {
            return [
                'correo' => [
                    'required',
                    'email',
                    'regex:/^[\w\.-]+@[\w\.-]+\.[\w]{2,4}$/i', // Ejemplo de regex para email
                    'max:255',
                    'unique:usuarios,correo',
                ],
                'nip' => [
                    'required',
                    'string',
                    'min:8', // Por ejemplo, 8 caracteres
                    // Debe tener al menos una mayúscula, un número y un símbolo
                    'regex:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/',
                ],
            ];
        }
        ```
      * **Nota de POO:** Usar `Form Requests` es una aplicación de POO donde la lógica de validación se encapsula en una clase separada, haciendo el controlador más limpio y enfocado.

-----

## 3\. Conexión Única por Credencial

Esta política requiere un mecanismo para rastrear las sesiones activas.

  * **Solución Óptima:**
    1.  **Modificar la Tabla `USUARIOS`:** Añade una columna, por ejemplo, `session_token` (VARCHAR 255) y `last_login_at` (TIMESTAMP NULLABLE).
    2.  **Manejar el *Login* (Inicio de Sesión):**
          * Al iniciar sesión correctamente, genera un *token* seguro (usando `Str::random(60)` o un UUID).
          * Guarda este *token* en la columna **`session_token`** y actualiza **`last_login_at`**.
          * Almacena el mismo *token* en la sesión del usuario o en una *cookie* de sesión.
    3.  **Implementar un *Middleware*:**
          * Crea un *middleware* llamado `EnsureSingleSession` que se ejecute en cada solicitud de rutas protegidas.
          * Este *middleware* verifica si el `session_token` en la base de datos para el usuario autenticado coincide con el *token* almacenado en la sesión/cookie.
          * Si **NO** coinciden, significa que se ha iniciado una sesión nueva con las mismas credenciales en otro lugar. La sesión actual debe ser cerrada (`Auth::logout()`) y el usuario redirigido a *login* con un mensaje de advertencia.
    4.  **Manejar el *Logout* (Cierre de Sesión):** Al cerrar sesión, el `session_token` en la base de datos debe ser **anulado** (puesto a `NULL`) para permitir un futuro *login* limpio.

-----

## 4\. Inhabilitación Temporal por Intentos Fallidos

**Laravel** ya incluye una característica para esto en su *trait* **`ThrottlesLogins`**.

  * **Solución Óptima (Limitación de Tasa):**
      * El *trait* **`ThrottlesLogins`** (usado por defecto en el `LoginController` de **Laravel Breeze** o **Jetstream**) maneja la lógica de contar intentos fallidos y bloquear temporalmente el acceso.
      * **Personalización:**
          * **Contador:** Por defecto, utiliza la combinación de la dirección IP y el nombre de usuario/correo para contar los intentos fallidos en la caché.
          * **Ajuste de Parámetros:** En tu controlador de *Login*, puedes sobreescribir los métodos para cumplir con la política de 3 intentos y 30 minutos (1800 segundos):
            ```php
            use Illuminate\Foundation\Auth\ThrottlesLogins;

            class LoginController extends Controller
            {
                use ThrottlesLogins;

                // Define el nombre del campo de usuario/correo
                protected function username()
                {
                    return 'correo'; // Asumiendo que el campo es 'correo'
                }

                // Número máximo de intentos
                protected function maxAttempts()
                {
                    return 3;
                }

                // Tiempo de bloqueo en segundos (30 minutos * 60 segundos)
                protected function decayMinutes()
                {
                    return 30; // 30 minutos
                }
            }
            ```
      * **POO:** El uso de *Traits* en POO es una excelente manera de reutilizar código (la lógica de *throttling*) sin herencia compleja, aplicando el principio **DRY** (*Don't Repeat Yourself*).

## Resumen de Tecnologías y Principios POO

| Política | Mecanismo de Laravel | Principios POO / Seguridad |
| :--- | :--- | :--- |
| **1. Encriptación NIP** | `Hash::make()` / `bcrypt()` | Hashing de Contraseñas (Estándar de Seguridad) |
| **2. Patrón (Email/NIP)** | *Form Requests* con `regex` | Encapsulación (Validación) |
| **3. Conexión Única** | *Middleware* y columna `session_token` | Separación de Preocupaciones (Middleware) |
| **4. Inhabilitación** | *Trait* `ThrottlesLogins` | Reutilización de Código (Traits), Limitación de Tasa |